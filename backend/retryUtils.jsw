// backend/retryUtils.jsw
// Retry logic with exponential backoff and circuit breaker pattern

import { loggers } from './logger.jsw';

const logger = loggers.system;

/**
 * Error types that can be retried (network errors, timeouts, 5xx errors)
 */
const RETRYABLE_ERROR_PATTERNS = [
    'network',
    'timeout',
    'ETIMEDOUT',
    'ECONNRESET',
    'ENOTFOUND',
    'ECONNREFUSED',
    '500',
    '502',
    '503',
    '504',
    'fetch failed',
    'Failed to fetch'
];

/**
 * Check if error is retryable
 */
export function isRetryableError(error) {
    if (!error) return false;

    const errorString = error.toString().toLowerCase();
    const messageString = (error.message || '').toLowerCase();

    return RETRYABLE_ERROR_PATTERNS.some(pattern =>
        errorString.includes(pattern.toLowerCase()) ||
        messageString.includes(pattern.toLowerCase())
    );
}

/**
 * Calculate exponential backoff delay
 * @param {number} attempt - Current attempt number (0-indexed)
 * @param {number} baseDelay - Base delay in milliseconds (default 1000ms)
 * @param {number} maxDelay - Maximum delay in milliseconds (default 16000ms)
 */
export function calculateBackoff(attempt, baseDelay = 1000, maxDelay = 16000) {
    const delay = baseDelay * Math.pow(2, attempt);
    return Math.min(delay, maxDelay);
}

/**
 * Sleep for specified milliseconds
 */
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Retry a function with exponential backoff
 * @param {Function} fn - Async function to retry
 * @param {Object} options - Retry options
 * @param {number} options.maxAttempts - Maximum number of attempts (default 3)
 * @param {number} options.baseDelay - Base delay in milliseconds (default 1000)
 * @param {number} options.maxDelay - Maximum delay in milliseconds (default 16000)
 * @param {Function} options.shouldRetry - Custom function to determine if error should be retried
 * @param {string} options.operationName - Name of operation for logging
 */
export async function retry(fn, options = {}) {
    const {
        maxAttempts = 3,
        baseDelay = 1000,
        maxDelay = 16000,
        shouldRetry = isRetryableError,
        operationName = 'operation'
    } = options;

    let lastError;

    for (let attempt = 0; attempt < maxAttempts; attempt++) {
        try {
            logger.debug(`Attempt ${attempt + 1}/${maxAttempts} for ${operationName}`);

            const result = await fn();

            if (attempt > 0) {
                logger.info(`${operationName} succeeded after ${attempt + 1} attempts`);
            }

            return result;

        } catch (error) {
            lastError = error;

            const isLastAttempt = attempt === maxAttempts - 1;
            const canRetry = shouldRetry(error);

            if (isLastAttempt || !canRetry) {
                logger.error(
                    `${operationName} failed after ${attempt + 1} attempts`,
                    error,
                    { canRetry, isLastAttempt }
                );
                throw error;
            }

            const delay = calculateBackoff(attempt, baseDelay, maxDelay);

            logger.warn(
                `${operationName} failed (attempt ${attempt + 1}/${maxAttempts}), retrying in ${delay}ms`,
                { error: error.message }
            );

            await sleep(delay);
        }
    }

    throw lastError;
}

/**
 * Circuit breaker state
 */
const CircuitState = {
    CLOSED: 'CLOSED',     // Normal operation
    OPEN: 'OPEN',         // Too many failures, block requests
    HALF_OPEN: 'HALF_OPEN' // Testing if service recovered
};

/**
 * Circuit Breaker class to prevent cascading failures
 */
export class CircuitBreaker {
    constructor(options = {}) {
        this.failureThreshold = options.failureThreshold || 5; // Open after 5 failures
        this.resetTimeout = options.resetTimeout || 60000; // Try to close after 60 seconds
        this.halfOpenMaxAttempts = options.halfOpenMaxAttempts || 3; // Test with 3 requests

        this.state = CircuitState.CLOSED;
        this.failureCount = 0;
        this.successCount = 0;
        this.nextAttemptTime = Date.now();
        this.name = options.name || 'CircuitBreaker';

        logger.info(`Circuit breaker '${this.name}' initialized`, {
            failureThreshold: this.failureThreshold,
            resetTimeout: this.resetTimeout
        });
    }

    /**
     * Execute function with circuit breaker protection
     */
    async execute(fn) {
        // Check circuit state
        if (this.state === CircuitState.OPEN) {
            if (Date.now() < this.nextAttemptTime) {
                const error = new Error(`Circuit breaker '${this.name}' is OPEN (too many failures)`);
                logger.warn(`Request blocked by circuit breaker '${this.name}'`, {
                    state: this.state,
                    failureCount: this.failureCount,
                    nextAttemptTime: new Date(this.nextAttemptTime).toISOString()
                });
                throw error;
            }

            // Try transitioning to HALF_OPEN
            this.state = CircuitState.HALF_OPEN;
            this.successCount = 0;
            logger.info(`Circuit breaker '${this.name}' transitioning to HALF_OPEN`);
        }

        try {
            const result = await fn();

            // Success - handle based on state
            if (this.state === CircuitState.HALF_OPEN) {
                this.successCount++;

                if (this.successCount >= this.halfOpenMaxAttempts) {
                    // Enough successes - close circuit
                    this.state = CircuitState.CLOSED;
                    this.failureCount = 0;
                    this.successCount = 0;
                    logger.info(`Circuit breaker '${this.name}' CLOSED (service recovered)`);
                }
            } else if (this.state === CircuitState.CLOSED) {
                // Reset failure count on success
                if (this.failureCount > 0) {
                    logger.debug(`Circuit breaker '${this.name}' failure count reset after success`);
                }
                this.failureCount = 0;
            }

            return result;

        } catch (error) {
            // Failure - increment counter
            this.failureCount++;

            logger.warn(`Circuit breaker '${this.name}' recorded failure`, {
                failureCount: this.failureCount,
                threshold: this.failureThreshold,
                state: this.state
            });

            if (this.failureCount >= this.failureThreshold || this.state === CircuitState.HALF_OPEN) {
                // Open circuit
                this.state = CircuitState.OPEN;
                this.nextAttemptTime = Date.now() + this.resetTimeout;

                logger.critical(`Circuit breaker '${this.name}' OPENED`, error, {
                    failureCount: this.failureCount,
                    nextAttemptTime: new Date(this.nextAttemptTime).toISOString()
                });
            }

            throw error;
        }
    }

    /**
     * Get current circuit breaker status
     */
    getStatus() {
        return {
            name: this.name,
            state: this.state,
            failureCount: this.failureCount,
            successCount: this.successCount,
            nextAttemptTime: this.state === CircuitState.OPEN
                ? new Date(this.nextAttemptTime).toISOString()
                : null
        };
    }

    /**
     * Manually reset circuit breaker
     */
    reset() {
        logger.info(`Circuit breaker '${this.name}' manually reset`);
        this.state = CircuitState.CLOSED;
        this.failureCount = 0;
        this.successCount = 0;
        this.nextAttemptTime = Date.now();
    }
}

/**
 * Global circuit breakers for external services
 */
const circuitBreakers = {
    airtable: new CircuitBreaker({
        name: 'Airtable',
        failureThreshold: 5,
        resetTimeout: 60000 // 1 minute
    }),

    email: new CircuitBreaker({
        name: 'Email',
        failureThreshold: 3,
        resetTimeout: 30000 // 30 seconds
    })
};

/**
 * Get circuit breaker by name
 */
export function getCircuitBreaker(name) {
    return circuitBreakers[name];
}

/**
 * Get status of all circuit breakers
 */
export function getCircuitBreakerStatus() {
    return Object.keys(circuitBreakers).reduce((status, key) => {
        status[key] = circuitBreakers[key].getStatus();
        return status;
    }, {});
}
