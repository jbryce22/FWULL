// backend/airtableRetryJob.jsw
// Job to retry failed Airtable syncs for registrations
import wixData from 'wix-data';
import { syncRegistrationToAirtable } from 'backend/airtable';
import { AIRTABLE, COLLECTIONS } from './constants.js';

/**
 * Retry syncing failed registrations to Airtable
 * Can be called manually or scheduled via Wix Jobs
 *
 * @param {number} maxRetries - Maximum number of times to retry a registration (default: 3)
 * @param {number} batchSize - Number of registrations to process per batch (default: 10)
 * @returns {Object} Summary of retry results
 */
export async function retryFailedAirtableSyncs(maxRetries = 3, batchSize = 10) {
    console.log('[Retry Job] Starting failed Airtable sync retry job');
    console.log(`[Retry Job] Config: maxRetries=${maxRetries}, batchSize=${batchSize}`);

    const results = {
        totalProcessed: 0,
        succeeded: 0,
        failed: 0,
        skipped: 0,
        errors: []
    };

    try {
        // Query for registrations with failed sync status that haven't exceeded max retries
        const failedRegs = await wixData.query(COLLECTIONS.REGISTRATION)
            .eq('airtableSyncStatus', AIRTABLE.SYNC_STATUS.FAILED)
            .lt('airtableSyncAttempts', maxRetries)
            .limit(batchSize)
            .find();

        console.log(`[Retry Job] Found ${failedRegs.items.length} registrations to retry`);

        if (failedRegs.items.length === 0) {
            console.log('[Retry Job] No failed registrations to retry');
            return results;
        }

        // Process each failed registration
        for (const reg of failedRegs.items) {
            results.totalProcessed++;

            console.log(`[Retry Job] Retrying registration ${reg._id} (attempt ${reg.airtableSyncAttempts + 1}/${maxRetries})`);

            try {
                // Attempt to sync to Airtable
                await syncRegistrationToAirtable(reg);

                // Success! Update status
                await wixData.update(COLLECTIONS.REGISTRATION, {
                    _id: reg._id,
                    airtableSyncStatus: AIRTABLE.SYNC_STATUS.SYNCED,
                    airtableSyncedAt: new Date(),
                    airtableSyncError: null
                });

                results.succeeded++;
                console.log(`[Retry Job] Successfully synced registration ${reg._id}`);

            } catch (error) {
                // Failed again - update attempt count
                const newAttempts = (reg.airtableSyncAttempts || 0) + 1;

                try {
                    await wixData.update(COLLECTIONS.REGISTRATION, {
                        _id: reg._id,
                        airtableSyncAttempts: newAttempts,
                        airtableSyncError: error.message || String(error),
                        lastSyncAttempt: new Date()
                    });

                    // If we've reached max retries, log it specially
                    if (newAttempts >= maxRetries) {
                        console.error(`[Retry Job] Registration ${reg._id} failed ${maxRetries} times - giving up`);
                        results.errors.push({
                            registrationId: reg._id,
                            playerName: reg.playerName,
                            error: `Max retries (${maxRetries}) exceeded`,
                            finalError: error.message
                        });
                    }
                } catch (updateErr) {
                    console.error(`[Retry Job] Failed to update attempt count for ${reg._id}:`, updateErr);
                }

                results.failed++;
                console.error(`[Retry Job] Failed to sync registration ${reg._id}:`, error.message);
            }
        }

        console.log('[Retry Job] Completed retry job');
        console.log(`[Retry Job] Results: ${results.succeeded} succeeded, ${results.failed} failed, ${results.skipped} skipped`);

        return results;

    } catch (error) {
        console.error('[Retry Job] Fatal error in retry job:', error);
        throw error;
    }
}

/**
 * Get statistics about failed Airtable syncs
 * Useful for monitoring and alerting
 *
 * @returns {Object} Statistics about sync failures
 */
export async function getFailedSyncStats() {
    try {
        const stats = {
            totalFailed: 0,
            failedOnce: 0,
            failedTwice: 0,
            failedThreePlus: 0,
            oldestFailure: null,
            recentFailures: []
        };

        // Get all failed registrations
        const failedRegs = await wixData.query(COLLECTIONS.REGISTRATION)
            .eq('airtableSyncStatus', AIRTABLE.SYNC_STATUS.FAILED)
            .ascending('lastSyncAttempt')
            .find();

        stats.totalFailed = failedRegs.items.length;

        // Categorize by attempt count
        failedRegs.items.forEach(reg => {
            const attempts = reg.airtableSyncAttempts || 0;
            if (attempts === 1) stats.failedOnce++;
            else if (attempts === 2) stats.failedTwice++;
            else if (attempts >= 3) stats.failedThreePlus++;
        });

        // Get oldest failure
        if (failedRegs.items.length > 0) {
            const oldest = failedRegs.items[0];
            stats.oldestFailure = {
                registrationId: oldest._id,
                playerName: oldest.playerName,
                lastAttempt: oldest.lastSyncAttempt,
                attempts: oldest.airtableSyncAttempts,
                error: oldest.airtableSyncError
            };
        }

        // Get most recent failures (last 5)
        const recentFailed = await wixData.query(COLLECTIONS.REGISTRATION)
            .eq('airtableSyncStatus', AIRTABLE.SYNC_STATUS.FAILED)
            .descending('lastSyncAttempt')
            .limit(5)
            .find();

        stats.recentFailures = recentFailed.items.map(reg => ({
            registrationId: reg._id,
            playerName: reg.playerName,
            lastAttempt: reg.lastSyncAttempt,
            attempts: reg.airtableSyncAttempts,
            error: reg.airtableSyncError
        }));

        console.log('[Retry Job] Failed sync stats:', stats);
        return stats;

    } catch (error) {
        console.error('[Retry Job] Error getting failed sync stats:', error);
        throw error;
    }
}

/**
 * Manual trigger to retry a specific registration
 * Useful for troubleshooting
 *
 * @param {string} registrationId - The _id of the registration to retry
 * @returns {Object} Result of retry attempt
 */
export async function retrySpecificRegistration(registrationId) {
    console.log(`[Retry Job] Manual retry for registration ${registrationId}`);

    try {
        const reg = await wixData.get(COLLECTIONS.REGISTRATION, registrationId);

        if (!reg) {
            throw new Error(`Registration ${registrationId} not found`);
        }

        console.log(`[Retry Job] Found registration for ${reg.playerName}`);

        // Attempt sync
        await syncRegistrationToAirtable(reg);

        // Update status on success
        await wixData.update(COLLECTIONS.REGISTRATION, {
            _id: reg._id,
            airtableSyncStatus: AIRTABLE.SYNC_STATUS.SYNCED,
            airtableSyncedAt: new Date(),
            airtableSyncError: null
        });

        console.log(`[Retry Job] Successfully synced registration ${registrationId}`);
        return { success: true, registrationId };

    } catch (error) {
        console.error(`[Retry Job] Failed to sync registration ${registrationId}:`, error);

        // Update error info
        try {
            const reg = await wixData.get(COLLECTIONS.REGISTRATION, registrationId);
            await wixData.update(COLLECTIONS.REGISTRATION, {
                _id: registrationId,
                airtableSyncAttempts: (reg.airtableSyncAttempts || 0) + 1,
                airtableSyncError: error.message || String(error),
                lastSyncAttempt: new Date()
            });
        } catch (updateErr) {
            console.error(`[Retry Job] Failed to update error info:`, updateErr);
        }

        return {
            success: false,
            registrationId,
            error: error.message
        };
    }
}
